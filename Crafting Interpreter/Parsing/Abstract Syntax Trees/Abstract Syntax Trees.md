- Take example of *human interpreter*, an expression like `1 + 2 * 3 - 4`
- We know BODMAS and hence we know which ops will occur first(precedence)
- One way to visualize that precedence is using a tree. Leaf nodes are numbers, and interior nodes are operators with branches for each of their operands.
- In order to evaluate an arithmetic node, you need to know the numeric values of its sub-trees, so you have to evaluate those first. That means working your way from the leaves up to the root—a _post-order_ traversal:![[Example AST of expression.png]]
- Given a expression, a parse tree can easily be build and that parse tree can simply be evaluated using *post order traversal*. So it looks like a good option for code
# Implementation
Syntax trees are not homogeneous. Unary expressions have a single operand, binary expressions have two, and literals have none. It might not be a good idea to use a single class to represent every form of *Expression*.We could but better idea might be to use a single `Expression` base class and for each production under `expression` we create a subclass that has fields for the nonterminals specific to that rule.
Something like this:
```java
abstract class Expr { 
  static class Binary extends Expr {
    Binary(Expr left, Token operator, Expr right) {
      this.left = left;
      this.operator = operator;
      this.right = right;
    }

    final Expr left;
    final Token operator;
    final Expr right;
  }

  // Other expressions...
}
```
- Note that these are disoriented objects(have no methods) and it does make sense, it should be plain data and not have some behavior. These ASTs are generated by Parser and used by interpreter. ASTs enable them to communicate.
# Working with ASTs
- Just think that Interpreter is traversing this AST.
- For each syntax node type(like binary exp, unary, etc...) behaviour is gonna be different
	- For binary, we first parse left and right subtree and then evaluate using root node of subtree as operator
	- For unary, get operator from left node and operand from right subtree
## How should the code for Interpreter be organized?
1. First Choice can be something like this:
	```java
	if (expr instanceof Expr.Binary) {
	  // ...
	} else if (expr instanceof Expr.Grouping) {
	  // ...
	} else // ...
	```
	Issue: But all of those sequential type tests are slow. Expression types whose names are alphabetically later would take longer to execute because they’d fall through more `if` cases before finding the right type.
2. We could add an `interpret()` method on the classes themselves but that fails when ASTs are shared by domain(like interpreter/parser/resolver). If we added instance methods to the expression classes for every one of those operations, that would smush a bunch of different domains together. BTW this is the **Interpreter Pattern** from the GoF book.
### The Expression Problem
We could add a method on each of the syntax node classes like `Expr.Binary` etc... for each the operations like ![[Interpreter Pattern.png]]
Issue: Java(an OOPL) assumes that all of the code in one row naturally hangs together.It figures all the things you do with a type are likely related to each other, and the language makes it easy to define them together as methods inside the same class. This makes simpler to add new class without messing with existing method but it makes it a pain in the butt to add new ops, that means cracking open each of those existing classes and adding a method to it.
In a function PL(like Haskell), to implement an operation for a number of different types, you define a single function. In the body of that function, you use _pattern matching_ to implement the operation for each type all in one place. But, conversely, adding a new type is hard. You have to go back and add a new case to all of the pattern matches in all of the existing functions.
- A bunch of smart language nerds noticed that neither style made it easy to add _both_ rows and columns to the table. They called this difficulty the “expression problem” because—like we are now—they first ran into it when they were trying to figure out the best way to model expression syntax tree nodes in a compiler.
### The Visitor Pattern
- Name is nothing like its working
- The pattern isn’t about `visiting`, and the `accept` method in it doesn’t conjure up any helpful imagery either. Many think the pattern has to do with traversing trees, which isn’t the case at all. We _are_ going to use it on a set of classes that are tree-like, but that’s a coincidence. As you’ll see, the pattern works as well on a single object.
- This pattern approximates Functional Behavior in OOP Language
- We can define all of the behavior for a new operation on a set of types in one place, without having to touch the types themselves.
- We create an `interface` having `visit<...>` function that has code for behavior for a specific syntax node type `<...>` for that operation, for eg,
```java
/*We can add the following abstract method to base class*/
class Expr {
	abstract <R> R accept(Visitor<R> visitor);
	...
	/* and this interface*/
	interface Visitor<R> {
		R visitUnaryExpr(Unary expr);
		...
	}
	/*and each of the subclass overrides*/
	class Binary extends Expr {
		@Override
		<R> R accept(Visitor<R> visitor) {
			return visitor.visitBinaryExpr(this);
		}
		...
	}
}
```
and To perform an operation on a expression, we call its `accept()` method and pass in the visitor for the operation we want to execute. The expression—the specific subclass’s overriding implementation of `accept()`—turns around and calls the appropriate visit method on the visitor and passes _itself_ to it.
